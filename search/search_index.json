{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CrazyComet Instructions Preparation Before starting the game a test calibration is accomplished in order to reset the position of the comets. Game-goal Get more points than the other team to win the game. Game-history Every player gets assigned to a turret with the associated controller. The players try to shoot the rotating object by controlling the turret with the controller (see controls section). For every hit the players get a point. The team wich reaches ten point first wins. One player can only shoot five times in a row. Afterwards the turret needs to cool down for three seconds. When a player shoots the white LED on the turret lights up. After hitting the target the green LED lights up. Game-end The game ends as soon as one team reaches ten points. The team with ten points wins. Controls left joystick: control turret RT: shooting B: ready","title":"Instructions"},{"location":"#crazycomet-instructions","text":"","title":"CrazyComet Instructions"},{"location":"#preparation","text":"Before starting the game a test calibration is accomplished in order to reset the position of the comets.","title":"Preparation"},{"location":"#game-goal","text":"Get more points than the other team to win the game.","title":"Game-goal"},{"location":"#game-history","text":"Every player gets assigned to a turret with the associated controller. The players try to shoot the rotating object by controlling the turret with the controller (see controls section). For every hit the players get a point. The team wich reaches ten point first wins. One player can only shoot five times in a row. Afterwards the turret needs to cool down for three seconds. When a player shoots the white LED on the turret lights up. After hitting the target the green LED lights up.","title":"Game-history"},{"location":"#game-end","text":"The game ends as soon as one team reaches ten points. The team with ten points wins.","title":"Game-end"},{"location":"#controls","text":"left joystick: control turret RT: shooting B: ready","title":"Controls"},{"location":"documentation/","text":"Documentation This documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here . Setup To use MkDocs the requirements.txt have to be installed with: pip3 install -r requirements.txt Info On the Controller and Gamecontrol Repository this only works on a Raspberry Pi Local build To build the documentation for local use run: mkdocs serve Now you can access the documentation on the address shown in the terminal ( http://localhost:8000 ) Info When running on a Raspberry Pi execute the following command to access the Documentation from an other PC in the same network. mkdocs serve -a <ip of your raspberry pi>:8000 Deploy When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually. Useful Commands Diagrams Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Documentation"},{"location":"documentation/#documentation","text":"This documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here .","title":"Documentation"},{"location":"documentation/#setup","text":"To use MkDocs the requirements.txt have to be installed with: pip3 install -r requirements.txt Info On the Controller and Gamecontrol Repository this only works on a Raspberry Pi","title":"Setup"},{"location":"documentation/#local-build","text":"To build the documentation for local use run: mkdocs serve Now you can access the documentation on the address shown in the terminal ( http://localhost:8000 ) Info When running on a Raspberry Pi execute the following command to access the Documentation from an other PC in the same network. mkdocs serve -a <ip of your raspberry pi>:8000","title":"Local build"},{"location":"documentation/#deploy","text":"When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually.","title":"Deploy"},{"location":"documentation/#useful-commands","text":"","title":"Useful Commands"},{"location":"documentation/#diagrams","text":"Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Diagrams"},{"location":"game_concept/","text":"CrazyComet Concept Basic-principle Two teams with three players each will be drawn. Each of these players controls a turret with the respective controller. An object rotating in a circle or bobbing up and down must be shot down with a turret. For every hit the player gets points. The team that has the most points after a certain time has elapsed wins. Rotating object The middle part is constructed with two steppers motors (see hardware documentation) to achieve a rotating and tilting movement. The turret is controlled by a raspberry pi. Turrets The turrets are operating with two servo motors. The lower one creates the horizontal and the upper one the vertical movement. The upper servo motor also controls the position of the laser. The turrets can be controlled by the controller (see controller setting in instructions). Two LEDs are also integrated in this 3D-Print. (Red LED: lights while shooting, Green LED: after hitting the target). The turrets are controlled by another raspberry pi. Display The displays show the points of every team and are controlled by another raspberry pi. Usefull Links In order to work with/on this project the following links might be helpful Game Code Hardware 4D-Game SDK Documentation Coding Style","title":"Game Concept"},{"location":"game_concept/#crazycomet-concept","text":"","title":"CrazyComet Concept"},{"location":"game_concept/#basic-principle","text":"Two teams with three players each will be drawn. Each of these players controls a turret with the respective controller. An object rotating in a circle or bobbing up and down must be shot down with a turret. For every hit the player gets points. The team that has the most points after a certain time has elapsed wins.","title":"Basic-principle"},{"location":"game_concept/#rotating-object","text":"The middle part is constructed with two steppers motors (see hardware documentation) to achieve a rotating and tilting movement. The turret is controlled by a raspberry pi.","title":"Rotating object"},{"location":"game_concept/#turrets","text":"The turrets are operating with two servo motors. The lower one creates the horizontal and the upper one the vertical movement. The upper servo motor also controls the position of the laser. The turrets can be controlled by the controller (see controller setting in instructions). Two LEDs are also integrated in this 3D-Print. (Red LED: lights while shooting, Green LED: after hitting the target). The turrets are controlled by another raspberry pi.","title":"Turrets"},{"location":"game_concept/#display","text":"The displays show the points of every team and are controlled by another raspberry pi.","title":"Display"},{"location":"game_concept/#usefull-links","text":"In order to work with/on this project the following links might be helpful Game Code Hardware 4D-Game SDK Documentation Coding Style","title":"Usefull Links"},{"location":"setup/","text":"Setup To start the game plug in the two power chords connected to the playing field. After about 1 minute the central tower will start to calibrate itself. In the next couple minutes all turrets will begin to light up in blue and the displays will show a round logo. Gamepad The controller can be started by pressing and holding the \"home\" button until the LEDs start to blink green and blue. Once they stop blinking the gamepad is connected to a turret. The order in wich the gamepads are connected is always random. You can find out the order by pressing \"B\" on every gamepad one after another. The turret who lights up green is the one connected to the gamepad. No connection Sometimes one or two controllers won't pair. To fix this problem disconnect and reconnect the USB dongle from the Raspberry Pi which is not connected to any gamepad. The turret light will turn of for some time. After this the turret will start up again. Warning If you have limited knowledge about electronics or the game itself, please seek support from someone who does.","title":"Setup"},{"location":"setup/#setup","text":"To start the game plug in the two power chords connected to the playing field. After about 1 minute the central tower will start to calibrate itself. In the next couple minutes all turrets will begin to light up in blue and the displays will show a round logo.","title":"Setup"},{"location":"setup/#gamepad","text":"The controller can be started by pressing and holding the \"home\" button until the LEDs start to blink green and blue. Once they stop blinking the gamepad is connected to a turret. The order in wich the gamepads are connected is always random. You can find out the order by pressing \"B\" on every gamepad one after another. The turret who lights up green is the one connected to the gamepad.","title":"Gamepad"},{"location":"setup/#no-connection","text":"Sometimes one or two controllers won't pair. To fix this problem disconnect and reconnect the USB dongle from the Raspberry Pi which is not connected to any gamepad. The turret light will turn of for some time. After this the turret will start up again. Warning If you have limited knowledge about electronics or the game itself, please seek support from someone who does.","title":"No connection"},{"location":"coding-style/cpp/","text":"C++ Coding Style Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into `c++ core guidelines' Naming conventions Variables The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global variables are defined outside of all functions, usually on top of the program. The variable will hold their value throughout the lifetime of the program. Global variables should be defined in a snake_case style, when possible at the start of the file. Example: int global_variable ; Local variables are defined, initially set and consumed within a function, method or block. These variables lifetime is confined within the lifetime (time of execution) of a function (method or block). Local variables should be defined the same way as global variables. The main difference for local variables is a defined prefix m_ . m_ stands for \"member\" data. int m_local_variable ; Constants & Preprocessor Values Constants are expressions with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: #define PI_VALUE 3.14159 const int PI_VALUE = 3.14159 ; Functions Functions can be written as non-returning and returning type. They should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFuntion () { // do some stuff } Classes (Types, Template parameters) C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. A class as well as an object should be defined with PascalCase notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ){ brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int m_current_speed ; }; void GeneralCar::setSpeed ( int new_speed ){ m_current_speed = new_speed ; } int main (){ // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; } Comments If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. Example // divides up two double values double division ( double dividend , double divisor ){ return ( dividend / divisor ); } Documentation: The documentation of the written code is created automatically. To provide the needed Information every function, class or method needs a descriptive block comment ( /** */ ) with a special format. For a detailed explanation click here Example: /** <Description> @param some_variable <Description of some_variable> @return <Description> */ int someFunction ( char some_variable ) { } Head of File: In order to get quick information about the .cpp and .hpp files purpose there should be a Header comment included. Therefor the /** */ format of commenting should be used. Example: /** <Short description of the files function> Projekt: <Name of the Projekt> Author: <Authors Name> Date of Creation: <Date> */","title":"C++ Coding Style"},{"location":"coding-style/cpp/#c-coding-style","text":"Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into `c++ core guidelines'","title":"C++ Coding Style"},{"location":"coding-style/cpp/#naming-conventions","text":"","title":"Naming conventions"},{"location":"coding-style/cpp/#variables","text":"The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global variables are defined outside of all functions, usually on top of the program. The variable will hold their value throughout the lifetime of the program. Global variables should be defined in a snake_case style, when possible at the start of the file. Example: int global_variable ; Local variables are defined, initially set and consumed within a function, method or block. These variables lifetime is confined within the lifetime (time of execution) of a function (method or block). Local variables should be defined the same way as global variables. The main difference for local variables is a defined prefix m_ . m_ stands for \"member\" data. int m_local_variable ;","title":"Variables"},{"location":"coding-style/cpp/#constants-preprocessor-values","text":"Constants are expressions with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: #define PI_VALUE 3.14159 const int PI_VALUE = 3.14159 ;","title":"Constants &amp; Preprocessor Values"},{"location":"coding-style/cpp/#functions","text":"Functions can be written as non-returning and returning type. They should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFuntion () { // do some stuff }","title":"Functions"},{"location":"coding-style/cpp/#classes-types-template-parameters","text":"C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. A class as well as an object should be defined with PascalCase notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ){ brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int m_current_speed ; }; void GeneralCar::setSpeed ( int new_speed ){ m_current_speed = new_speed ; } int main (){ // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; }","title":"Classes (Types, Template parameters)"},{"location":"coding-style/cpp/#comments","text":"If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. Example // divides up two double values double division ( double dividend , double divisor ){ return ( dividend / divisor ); } Documentation: The documentation of the written code is created automatically. To provide the needed Information every function, class or method needs a descriptive block comment ( /** */ ) with a special format. For a detailed explanation click here Example: /** <Description> @param some_variable <Description of some_variable> @return <Description> */ int someFunction ( char some_variable ) { } Head of File: In order to get quick information about the .cpp and .hpp files purpose there should be a Header comment included. Therefor the /** */ format of commenting should be used. Example: /** <Short description of the files function> Projekt: <Name of the Projekt> Author: <Authors Name> Date of Creation: <Date> */","title":"Comments"},{"location":"coding-style/git/","text":"GIT Commit Style In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. e.g. git commit -m \"ADD function XY()\" REMOVE Is used whenever a major part of the code is removed. This scenario should be rater infrequent. e.g. git commit -m \"REMOVE variable XY\" FIX Used for minor changes of an already existing part of the code. e.g git commit -m \"FIX functionality of XY\" UPDATE Is used when there is a major change in multiple code-segments. e.g git commit -m \"UPDATE setup of analog sensors\"","title":"GIT"},{"location":"coding-style/git/#git","text":"","title":"GIT"},{"location":"coding-style/git/#commit-style","text":"In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. e.g. git commit -m \"ADD function XY()\" REMOVE Is used whenever a major part of the code is removed. This scenario should be rater infrequent. e.g. git commit -m \"REMOVE variable XY\" FIX Used for minor changes of an already existing part of the code. e.g git commit -m \"FIX functionality of XY\" UPDATE Is used when there is a major change in multiple code-segments. e.g git commit -m \"UPDATE setup of analog sensors\"","title":"Commit Style"},{"location":"coding-style/python/","text":"Python Coding Style Besides consistency as a main aspect of good code, the second most important aspect is a certain style which the average python programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into the `PEP8 - Style Guide for Python Code' Naming conventions Variables The name of a variable should be as accurate as possible and as short as possible at the same time. Example: # don't x x = 10 + 5 # do res res = 10 + 5 A variable can be used in two different scenarios. Global variables are defined outside of all functions, usually on top of the program. They should only be used if absolutely necessary. A global variable will hold their value throughout the lifetime of the program. Global variables should be defined in a snake_case style, when possible at the start of the file. If the variable should only be used in it's module the name should start and end with two underscores. Example: global_variable _private_global_variable Local variables are defined, initially set and consumed within a function, method or block. These variables lifetime is confined within the lifetime (time of execution) of a function (method or block). Local variables should be defined the same way as global variables. local_variable Constants Constants are expressions with a fixed value. They are defined on a global (modul) level. The naming convention for constants prescribes that all letters are upper case letters with snake case subdivision. Example: PI_VALUE = 3.14159 Functions Functions should be named in snake_case like variables. Even though Python isn't strictly typesafe it is good practice to define a return-type and the type of the parameters. Example: def example_function ( some_value : int ) -> bool : # do some stuff Classes (Types, Template parameters) Python is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. A class as well as an object should be defined with PascalCase notation. Methods and Attributes: The first parameter of the __init__ function should always be called self . Private methods or attributes always start with two underscores. Example: class Car : brand max_speed power _current_speed def __init__ ( self , ini_brand , ini_speed , ini_power ){ self . brand = ini_brand self . max_speed = ini_speed self . power = ini_power } Comments If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. Example: # divides up two double values def division ( dividend : float , divisor : float ) -> float : return ( dividend / divisor ) Documentation: The documentation of the written code is created automatically. To provide the needed Information every function, class or method needs a docstring with a special format. Example: def some_function ( some_variable : int ) -> int : \"\"\" <Description> Arguments: some_variable: <Description> Returns: <Description \"\"\" Head of File: In order to get quick information about the .py files purpose there should be a docstring at the beginning of the file. Example: #!/usr/bin/env python3 \"\"\" Created: <MM/DD/YY> by: <Author> <Description> \"\"\"","title":"Python"},{"location":"coding-style/python/#python-coding-style","text":"Besides consistency as a main aspect of good code, the second most important aspect is a certain style which the average python programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into the `PEP8 - Style Guide for Python Code'","title":"Python Coding Style"},{"location":"coding-style/python/#naming-conventions","text":"","title":"Naming conventions"},{"location":"coding-style/python/#variables","text":"The name of a variable should be as accurate as possible and as short as possible at the same time. Example: # don't x x = 10 + 5 # do res res = 10 + 5 A variable can be used in two different scenarios. Global variables are defined outside of all functions, usually on top of the program. They should only be used if absolutely necessary. A global variable will hold their value throughout the lifetime of the program. Global variables should be defined in a snake_case style, when possible at the start of the file. If the variable should only be used in it's module the name should start and end with two underscores. Example: global_variable _private_global_variable Local variables are defined, initially set and consumed within a function, method or block. These variables lifetime is confined within the lifetime (time of execution) of a function (method or block). Local variables should be defined the same way as global variables. local_variable","title":"Variables"},{"location":"coding-style/python/#constants","text":"Constants are expressions with a fixed value. They are defined on a global (modul) level. The naming convention for constants prescribes that all letters are upper case letters with snake case subdivision. Example: PI_VALUE = 3.14159","title":"Constants"},{"location":"coding-style/python/#functions","text":"Functions should be named in snake_case like variables. Even though Python isn't strictly typesafe it is good practice to define a return-type and the type of the parameters. Example: def example_function ( some_value : int ) -> bool : # do some stuff","title":"Functions"},{"location":"coding-style/python/#classes-types-template-parameters","text":"Python is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. A class as well as an object should be defined with PascalCase notation. Methods and Attributes: The first parameter of the __init__ function should always be called self . Private methods or attributes always start with two underscores. Example: class Car : brand max_speed power _current_speed def __init__ ( self , ini_brand , ini_speed , ini_power ){ self . brand = ini_brand self . max_speed = ini_speed self . power = ini_power }","title":"Classes (Types, Template parameters)"},{"location":"coding-style/python/#comments","text":"If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. Example: # divides up two double values def division ( dividend : float , divisor : float ) -> float : return ( dividend / divisor ) Documentation: The documentation of the written code is created automatically. To provide the needed Information every function, class or method needs a docstring with a special format. Example: def some_function ( some_variable : int ) -> int : \"\"\" <Description> Arguments: some_variable: <Description> Returns: <Description \"\"\" Head of File: In order to get quick information about the .py files purpose there should be a docstring at the beginning of the file. Example: #!/usr/bin/env python3 \"\"\" Created: <MM/DD/YY> by: <Author> <Description> \"\"\"","title":"Comments"}]}